{"version":3,"sources":["common/dcf-lazyLoad.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_typeof","Symbol","iterator","obj","constructor","_classCallCheck","instance","TypeError","root","factory","define","amd","exports","module","dcfLazyLoad","undefined","LazyLoad","imagesList","observerConfig","classNames","_this","this","onIntersection","entries","observer","imageCount","disconnect","entry","intersectionRatio","thresholds","preloadImage","applyImage","unobserve","value","image","src","dataset","srcset","Error","classList","add","removeAttribute","forEach","className","arguments","Promise","resolve","reject","Image","onload","onerror","fetchImage","catch","err","mes","images","window","IntersectionObserver","contains","observe","loadImagesImmediately"],"mappings":"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","file":"dcf-lazyLoad.min.js","sourcesContent":["'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n;(function (root, factory) {\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine([], factory);\n\t} else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n\t\tmodule.exports = factory();\n\t} else {\n\t\troot.dcfLazyLoad = factory();\n\t}\n})(undefined, function () {\n\tvar LazyLoad = function () {\n\t\t/**\n   * class constructor\n   * @param {imagesList} nodelist of selected images\n   * @param {observerConfig} object of intersectionObserver configuration\n   * @param {classNames} array of classes applied\n   */\n\t\tfunction LazyLoad(imagesList, observerConfig, classNames) {\n\t\t\tvar _this = this;\n\n\t\t\t_classCallCheck(this, LazyLoad);\n\n\t\t\tthis.onIntersection = function (entries, observer) {\n\n\t\t\t\t// Disconnect if we've already loaded all of the images\n\t\t\t\tif (_this.imageCount === 0) {\n\t\t\t\t\t_this.observer.disconnect();\n\t\t\t\t}\n\n\t\t\t\t// Loop through the entries\n\t\t\t\tfor (var i = 0; i < entries.length; i++) {\n\t\t\t\t\tvar entry = entries[i];\n\n\t\t\t\t\t// Are we in viewport?\n\t\t\t\t\t// console.log(entry.intersectionRatio);\n\n\t\t\t\t\tif (entry.intersectionRatio > observer.thresholds[0] && entry.intersectionRatio < observer.thresholds[1]) {\n\t\t\t\t\t\t_this.preloadImage(entry.target);\n\t\t\t\t\t} else if (entry.intersectionRatio > observer.thresholds[1]) {\n\t\t\t\t\t\t_this.imageCount--;\n\t\t\t\t\t\t_this.applyImage(entry.target);\n\t\t\t\t\t\t_this.observer.unobserve(entry.target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.imagesList = imagesList;\n\t\t\tthis.observerConfig = observerConfig;\n\t\t\tthis.classNames = classNames; // add onEnter, onEnterActive?\n\t\t}\n\n\t\t/**\n   * Apply the image: preloaded image is loaded but not applied to actual image element\n   * @param {string} image: the image element that we are targetting\n   */\n\n\n\t\t_createClass(LazyLoad, [{\n\t\t\tkey: 'applyImage',\n\t\t\tvalue: function applyImage(image) {\n\t\t\t\tvar src = image.dataset.src;\n\t\t\t\tvar srcset = image.dataset.srcset || null;\n\n\t\t\t\tif (!src) {\n\t\t\t\t\tthrow new Error('No image src attribute provided');\n\t\t\t\t}\n\n\t\t\t\t// Prevent this from being lazy loaded a second time.\n\t\t\t\timage.classList.add('dcf-lazy-img-loaded');\n\n\t\t\t\tsrc && (image.src = src);\n\t\t\t\tsrc && image.removeAttribute('data-src');\n\t\t\t\tsrcset && (image.srcset = srcset);\n\t\t\t\tsrcset && image.removeAttribute('data-srcset');\n\t\t\t\tthis.classNames.length && this.classNames.forEach(function (className) {\n\t\t\t\t\treturn image.classList.add(className);\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'fetchImage',\n\n\n\t\t\t/**\n    * Fetches the image for the given source\n    * @param {string} src\n    * @param {string} srcset, defaults to null if not provided\n    */\n\t\t\tvalue: function fetchImage(src) {\n\t\t\t\tvar srcset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tvar image = new Image();\n\t\t\t\t\tsrc && (image.src = src);\n\t\t\t\t\tsrcset && (image.srcset = srcset);\n\n\t\t\t\t\timage.onload = resolve;\n\t\t\t\t\timage.onerror = reject;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/**\n    * Preloads the image\n    * @param {object} image\n    */\n\n\t\t}, {\n\t\t\tkey: 'preloadImage',\n\t\t\tvalue: function preloadImage(image) {\n\t\t\t\tvar src = image.dataset.src;\n\t\t\t\tvar srcset = image.dataset.srcset;\n\n\t\t\t\tif (!src) {\n\t\t\t\t\tthrow new Error('No image src attribute provided');\n\t\t\t\t}\n\n\t\t\t\treturn this.fetchImage(src, srcset).catch(function (err) {\n\t\t\t\t\treturn 'Image failed to fetch ' + err.mes;\n\t\t\t\t});\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'loadImagesImmediately',\n\n\n\t\t\t/**\n    * Load all of the images immediately\n    * @param {NodeListOf<Element>} images\n    */\n\t\t\tvalue: function loadImagesImmediately(images) {\n\t\t\t\t// foreach() is not supported in IE\n\t\t\t\tfor (var i = 0; i < images.length; i++) {\n\t\t\t\t\tvar image = images[i];\n\t\t\t\t\tthis.preloadImage(image);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n    * Disconnect the observer\n    */\n\n\t\t}, {\n\t\t\tkey: 'disconnect',\n\t\t\tvalue: function disconnect() {\n\t\t\t\tif (!this.observer) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.observer.disconnect();\n\t\t\t}\n\n\t\t\t/**\n    * On intersection\n    * @param {array} intersection entries\n    * @param {object} intersection observer\n    */\n\n\t\t}, {\n\t\t\tkey: 'initialize',\n\t\t\tvalue: function initialize() {\n\t\t\t\tif (!this.imagesList) return;\n\n\t\t\t\t// counter: keeps track of which images that hasn't been loaded\n\t\t\t\tthis.imageCount = this.imagesList.length;\n\n\t\t\t\t// If browser doesn't support intersection observer, load the images immediately\n\t\t\t\tif (!('IntersectionObserver' in window)) {\n\t\t\t\t\tthis.loadImagesImmediately(this.imagesList);\n\t\t\t\t} else {\n\t\t\t\t\t// It is supported, load the images\n\t\t\t\t\tthis.observer = new IntersectionObserver(this.onIntersection, this.observerConfig);\n\n\t\t\t\t\t// foreach() is not supported in IE\n\t\t\t\t\tfor (var i = 0; i < this.imageCount; i++) {\n\t\t\t\t\t\tvar image = this.imagesList[i];\n\t\t\t\t\t\tif (image.classList.contains('dcf-lazy-img-loaded')) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.observer.observe(image);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}]);\n\n\t\treturn LazyLoad;\n\t}();\n\n\treturn LazyLoad;\n});"]}